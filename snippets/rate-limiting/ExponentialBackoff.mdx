---
title: "Exponential Backoff Examples"
---

<CodeGroup dropdown>

```go exponential_backoff.go
package main

import (
	"fmt"
	"math"
	"net/http"
	"strconv"
	"time"
)

func makeRequestWithRetry(url string, apiKey string, maxRetries int) (*http.Response, error) {
	client := &http.Client{}
	for attempt := 0; attempt < maxRetries; attempt++ {
		req, err := http.NewRequest("GET", url, nil)
		if err != nil {
			return nil, err
		}
		req.Header.Set("X-API-KEY", apiKey)

		resp, err := client.Do(req)
		if err != nil {
			if attempt == maxRetries-1 {
				return nil, err
			}
			continue
		}

		if resp.StatusCode == http.StatusTooManyRequests { // 429
			retryAfter := resp.Header.Get("Retry-After")
			var delay time.Duration
			if retryAfter != "" {
				if seconds, err := strconv.Atoi(retryAfter); err == nil {
					delay = time.Duration(seconds) * time.Second
				}
			}
			if delay == 0 {
				ms := math.Min(1000*math.Pow(2, float64(attempt)), 60000)
				delay = time.Duration(ms) * time.Millisecond
			}
			fmt.Printf("Rate limited. Waiting %v before retry %d\n", delay, attempt+1)
			time.Sleep(delay)
			continue
		}

		return resp, nil
	}
	return nil, fmt.Errorf("max retries exceeded")
}
```

```typescript exponential_backoff.ts
export async function makeRequestWithRetry(
  url: string,
  options: RequestInit,
  maxRetries: number = 3
): Promise<Response> {
  let attempt = 0;
  while (attempt < maxRetries) {
    try {
      const response = await fetch(url, options);
      if (response.status === 429) {
        const retryAfter = response.headers.get("Retry-After");
        const delay = retryAfter
          ? parseInt(retryAfter, 10) * 1000
          : Math.min(1000 * Math.pow(2, attempt), 60_000);
        console.log(
          `Rate limited. Waiting ${delay}ms before retry ${attempt + 1}`
        );
        await new Promise((resolve) => setTimeout(resolve, delay));
        attempt += 1;
        continue;
      }
      return response;
    } catch (error) {
      if (attempt === maxRetries - 1) {
        throw error;
      }
      attempt += 1;
    }
  }
  throw new Error("Max retries exceeded");
}

// Usage
await makeRequestWithRetry("https://api.clemta.com/formations/123", {
  headers: { "X-API-KEY": "your_api_key" },
});
```

```rust exponential_backoff.rs
use reqwest::Client;
use std::time::Duration;
use tokio::time::sleep;

pub async fn make_request_with_retry(
    url: &str,
    api_key: &str,
    max_retries: u32,
) -> Result<reqwest::Response, Box<dyn std::error::Error>> {
    let client = Client::new();
    let mut attempt: u32 = 0;

    while attempt < max_retries {
        let response = client
            .get(url)
            .header("X-API-KEY", api_key)
            .send()
            .await?;

        if response.status() == 429 {
            let retry_after = response
                .headers()
                .get("Retry-After")
                .and_then(|h| h.to_str().ok())
                .and_then(|s| s.parse::<u64>().ok());

            let delay = retry_after
                .map(Duration::from_secs)
                .unwrap_or_else(|| {
                    let ms = (1000.0_f64 * 2.0_f64.powi(attempt as i32)).min(60000.0);
                    Duration::from_millis(ms as u64)
                });

            println!(
                "Rate limited. Waiting {:?} before retry {}",
                delay,
                attempt + 1
            );
            sleep(delay).await;
            attempt += 1;
            continue;
        }

        return Ok(response);
    }

    Err("Max retries exceeded".into())
}
```

```java ExponentialBackoff.java
import java.io.IOException;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.net.URI;
import java.util.Optional;

public class ExponentialBackoff {
  private static final HttpClient client = HttpClient.newHttpClient();

  public static HttpResponse<String> makeRequestWithRetry(
      String url, String apiKey, int maxRetries) throws IOException, InterruptedException {
    for (int attempt = 0; attempt < maxRetries; attempt++) {
      HttpRequest req = HttpRequest.newBuilder()
          .uri(URI.create(url))
          .header("X-API-KEY", apiKey)
          .GET()
          .build();

      HttpResponse<String> res = client.send(req, HttpResponse.BodyHandlers.ofString());
      if (res.statusCode() == 429) {
        Optional<String> retryAfter = res.headers().firstValue("Retry-After");
        long delayMs = retryAfter
            .map(s -> Long.parseLong(s) * 1000)
            .orElse(Math.min((long) Math.pow(2, attempt) * 1000L, 60_000L));
        System.out.printf("Rate limited. Waiting %dms before retry %d%n", delayMs, attempt + 1);
        Thread.sleep(delayMs);
        continue;
      }

      return res;
    }

    throw new RuntimeException("Max retries exceeded");
  }
}
```

```python exponential_backoff.py
import asyncio
import math
from typing import Optional

import aiohttp


async def make_request_with_retry(
    url: str, api_key: str, max_retries: int = 3
) -> aiohttp.ClientResponse:
    async with aiohttp.ClientSession() as session:
        for attempt in range(max_retries):
            try:
                headers = {"X-API-KEY": api_key}
                async with session.get(url, headers=headers) as resp:
                    if resp.status == 429:
                        retry_after = resp.headers.get("Retry-After")
                        delay_ms: Optional[float] = (
                            int(retry_after) * 1000 if retry_after else None
                        )
                        if delay_ms is None:
                            delay_ms = min(1000 * math.pow(2, attempt), 60000)
                        print(
                            f"Rate limited. Waiting {int(delay_ms)}ms before retry {attempt + 1}"
                        )
                        await asyncio.sleep(delay_ms / 1000)
                        continue
                    return resp
            except Exception:
                if attempt == max_retries - 1:
                    raise
        raise Exception("Max retries exceeded")
```

</CodeGroup>
